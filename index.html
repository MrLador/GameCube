<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Vector Pong в стиле Monument Valley</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(135deg, #a8edea, #fed6e3);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    background: #f0f4f8;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    border-radius: 20px;
    touch-action: none; /* отключаем стандартные жесты браузера */
  }
  canvas {
    display: block;
    background: #e0e7ff;
    border-radius: 20px;
  }
  #score {
    font-size: 2rem;
    font-weight: 700;
    color: #4a4a4a;
    margin: 10px 0;
    user-select: none;
  }
  #instructions {
    font-size: 1rem;
    color: #666;
    margin-top: 10px;
    user-select: none;
  }

  /* Вертикальный режим для мобильных */
  @media (max-width: 600px) {
    body {
      flex-direction: column;
    }
    #gameContainer {
      width: 90vw;
      height: 120vw; /* вертикальный прямоугольник */
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
    #instructions {
      display: none; /* скрываем инструкции на мобилках */
    }
  }

  /* Горизонтальный режим для десктопа */
  @media (min-width: 601px) {
    #gameContainer {
      width: 800px;
      height: 450px;
    }
    canvas {
      width: 800px !important;
      height: 450px !important;
    }
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="450"></canvas>
  <div id="score">0 : 0</div>
  <div id="instructions">Управление: W/S и стрелки вверх/вниз</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('gameContainer');
  const scoreDiv = document.getElementById('score');
  const instructionsDiv = document.getElementById('instructions');

  // Исходные размеры для логики игры
  const baseWidth = 800;
  const baseHeight = 450;

  // Параметры ракеток и мяча
  const paddleWidth = 15;
  const paddleHeight = 100;
  const paddleSpeed = 6;
  const ballRadius = 12;

  // Цвета мяча (пастельные)
  const ballColors = [
    '#a8edea', '#fed6e3', '#fcb69f', '#a1c4fd', '#c2e9fb', '#d4fc79', '#96e6a1'
  ];

  // Игроки
  const leftPaddle = {
    x: 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };
  const rightPaddle = {
    x: baseWidth - paddleWidth - 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };

  // Мяч
  const ball = {
    x: baseWidth / 2,
    y: baseHeight / 2,
    dx: 5,
    dy: 3,
    radius: ballRadius,
    color: ballColors[0]
  };

  // Счёт
  let scoreLeft = 0;
  let scoreRight = 0;

  // Управление с клавиатуры
  const keys = {};

  // Масштаб для адаптивности
  let scaleX = 1;
  let scaleY = 1;

  // Функция смены цвета мяча
  function changeBallColor() {
    let newColor;
    do {
      newColor = ballColors[Math.floor(Math.random() * ballColors.length)];
    } while (newColor === ball.color);
    ball.color = newColor;
  }

  // Обновление размеров canvas и масштабирования
  function resize() {
    const rect = container.getBoundingClientRect();
    canvas.width = baseWidth;
    canvas.height = baseHeight;

    // Масштаб для отрисовки и логики
    scaleX = rect.width / baseWidth;
    scaleY = rect.height / baseHeight;

    // Устанавливаем CSS размеры canvas для растягивания
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    // Сброс позиции ракеток и мяча, чтобы не выйти за границы
    leftPaddle.y = Math.min(leftPaddle.y, baseHeight - paddleHeight);
    rightPaddle.y = Math.min(rightPaddle.y, baseHeight - paddleHeight);
    ball.x = baseWidth / 2;
    ball.y = baseHeight / 2;
  }

  window.addEventListener('resize', resize);
  resize();

  // Обработка клавиатуры
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Обновление позиции ракеток с клавиатуры
  function updatePaddlesKeyboard() {
    // Левая ракетка: W/S
    if (keys['w']) {
      leftPaddle.y -= paddleSpeed;
    } else if (keys['s']) {
      leftPaddle.y += paddleSpeed;
    }
    // Правая ракетка: стрелки вверх/вниз
    if (keys['arrowup']) {
      rightPaddle.y -= paddleSpeed;
    } else if (keys['arrowdown']) {
      rightPaddle.y += paddleSpeed;
    }

    // Ограничение по краям
    leftPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, leftPaddle.y));
    rightPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, rightPaddle.y));
  }

  // Обработка касаний для мобильных (двух пальцев)
  // Каждый палец управляет своей ракеткой
  // При отпускании палец перестаёт двигать ракетку
  const ongoingTouches = {};

  function getTouchRelativeY(touch) {
    const rect = canvas.getBoundingClientRect();
    return (touch.clientY - rect.top) / scaleY;
  }

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      // Определяем, к какой половине экрана палец прикоснулся
      const rect = canvas.getBoundingClientRect();
      const xRel = (touch.clientX - rect.left) / scaleX;
      if (xRel < baseWidth / 2) {
        // Левая ракетка
        ongoingTouches[touch.identifier] = 'left';
      } else {
        // Правая ракетка
        ongoingTouches[touch.identifier] = 'right';
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      const paddleSide = ongoingTouches[touch.identifier];
      if (!paddleSide) continue;
      const y = getTouchRelativeY(touch) - paddleHeight / 2;
      if (paddleSide === 'left') {
        leftPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, y));
      } else if (paddleSide === 'right') {
        rightPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, y));
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  canvas.addEventListener('touchcancel', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  // Проверка столкновений мяча с ракетками
  function checkPaddleCollision() {
    // Левая ракетка
    if (
      ball.x - ball.radius <= leftPaddle.x + paddleWidth &&
      ball.x - ball.radius >= leftPaddle.x &&
      ball.y >= leftPaddle.y &&
      ball.y <= leftPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = leftPaddle.x + paddleWidth + ball.radius; // чтобы не застрял
      changeBallColor();
    }

    // Правая ракетка
    if (
      ball.x + ball.radius >= rightPaddle.x &&
      ball.x + ball.radius <= rightPaddle.x + paddleWidth &&
      ball.y >= rightPaddle.y &&
      ball.y <= rightPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = rightPaddle.x - ball.radius;
      changeBallColor();
    }
  }

  // Обновление позиции мяча и проверка столкновений со стенами
  function updateBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Верхняя и нижняя стенки
    if (ball.y - ball.radius <= 0) {
      ball.dy = -ball.dy;
      ball.y = ball.radius;
      changeBallColor();
    }
    if (ball.y + ball.radius >= baseHeight) {
      ball.dy = -ball.dy;
      ball.y = baseHeight - ball.radius;
      changeBallColor();
    }

    // Левая и правая стенки — очки
    if (ball.x - ball.radius <= 0) {
      scoreRight++;
      resetBall();
    }
    if (ball.x + ball.radius >= baseWidth) {
      scoreLeft++;
      resetBall();
    }
  }

  // Сброс мяча в центр с рандомным направлением
  function resetBall() {
    ball.x = baseWidth / 2;
    ball.y = baseHeight / 2;
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2);
    ball.dy = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
    ball.color = ballColors[0];
  }

  // Отрисовка ракеток
  function drawPaddle(paddle) {
    ctx.fillStyle = '#6c63ff';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#4b47a1';
    ctx.beginPath();
    ctx.moveTo(paddle.x, paddle.y);
    ctx.lineTo(paddle.x + paddleWidth, paddle.y);
    ctx.lineTo(paddle.x + paddleWidth, paddle.y + paddleHeight);
    ctx.lineTo(paddle.x, paddle.y + paddleHeight);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // Отрисовка мяча
  function drawBall() {
    ctx.fillStyle = ball.color;
    ctx.strokeStyle = '#4b47a1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  // Отрисовка счета
  function drawScore() {
    scoreDiv.textContent = `${scoreLeft} : ${scoreRight}`;
  }

  // Основной цикл игры
  function gameLoop() {
    ctx.clearRect(0, 0, baseWidth, baseHeight);

    updatePaddlesKeyboard();
    updateBall();
    checkPaddleCollision();

    drawPaddle(leftPaddle);
    drawPaddle(rightPaddle);
    drawBall();
    drawScore();

    requestAnimationFrame(gameLoop);
  }

  // Скрываем инструкции на мобильных
  function updateInstructionsVisibility() {
    if (window.innerWidth <= 600) {
      instructionsDiv.style.display = 'none';
    } else {
      instructionsDiv.style.display = 'block';
    }
  }
  window.addEventListener('resize', updateInstructionsVisibility);
  updateInstructionsVisibility();

  // Запуск игры
  resetBall();
  gameLoop();
})();
</script>

</body>
</html>
