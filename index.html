<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Vector Pong в стиле Monument Valley</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(135deg, #a8edea, #fed6e3);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    background: #f0f4f8;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    border-radius: 20px;
    touch-action: none;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    display: block;
    background: #e0e7ff;
    border-radius: 20px;
  }
  #scoreContainer {
    position: absolute;
    width: 100%;
    top: 10px;
    display: flex;
    justify-content: center;
    font-size: 2rem;
    font-weight: 700;
    color: #4a4a4a;
    user-select: none;
    pointer-events: none;
  }
  #scoreLeft, #scoreRight {
    user-select: none;
  }
  #instructions {
    font-size: 1rem;
    color: #666;
    margin-top: 10px;
    user-select: none;
  }
  #timer {
    position: absolute;
    top: 50px;
    width: 100%;
    text-align: center;
    font-size: 1.5rem;
    font-weight: 600;
    color: #4a4a4a;
    user-select: none;
    pointer-events: none;
  }

  /* ПК версия */
  @media (min-width: 601px) {
    #gameContainer {
      width: 800px;
      height: 450px;
      flex-direction: column;
    }
    canvas {
      width: 800px !important;
      height: 450px !important;
    }
    #scoreContainer {
      top: 10px;
      justify-content: center;
    }
    #scoreLeft, #scoreRight {
      margin: 0 10px;
    }
    #scoreLeft::after {
      content: " : ";
      margin: 0 10px;
      color: #4a4a4a;
    }
    #scoreRight::after {
      content: "";
    }
  }

  /* Мобильная версия */
  @media (max-width: 600px) {
    body {
      flex-direction: column;
    }
    #gameContainer {
      width: 90vw;
      height: 120vw;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 0 10px;
    }
    canvas {
      width: 70vw !important;
      height: 120vw !important;
      border-radius: 20px;
    }
    #scoreContainer {
      top: auto;
      bottom: 10px;
      width: auto;
      height: 100%;
      flex-direction: column;
      justify-content: space-between;
      left: 0;
      right: 0;
      pointer-events: none;
      user-select: none;
      font-size: 1.8rem;
      font-weight: 700;
      color: #4a4a4a;
      display: flex;
      position: absolute;
      width: 100%;
      padding: 0 10px;
    }
    #scoreLeft, #scoreRight {
      flex: 1;
      text-align: center;
      margin: 0;
    }
    #scoreLeft {
      order: 1;
      text-align: left;
    }
    #scoreRight {
      order: 2;
      text-align: right;
    }
    #scoreLeft::after, #scoreRight::after {
      content: "";
    }
    #instructions {
      display: none;
    }
    #timer {
      top: 10px;
      bottom: auto;
      font-size: 1.5rem;
      font-weight: 600;
      color: #4a4a4a;
      position: absolute;
      width: 100%;
      text-align: center;
      pointer-events: none;
      user-select: none;
    }
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="450"></canvas>
  <div id="scoreContainer">
    <div id="scoreLeft">0</div>
    <div id="scoreRight">0</div>
  </div>
  <div id="timer">2:00</div>
  <div id="instructions">Управление: W/S и стрелки вверх/вниз</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const container = document.getElementById('gameContainer');
  const scoreLeftDiv = document.getElementById('scoreLeft');
  const scoreRightDiv = document.getElementById('scoreRight');
  const timerDiv = document.getElementById('timer');
  const instructionsDiv = document.getElementById('instructions');

  const baseWidth = 800;
  const baseHeight = 450;

  const paddleWidth = 15;
  const paddleHeight = 100;
  const paddleSpeed = 6;
  const ballRadius = 12;

  const ballColors = [
    '#a8edea', '#fed6e3', '#fcb69f', '#a1c4fd', '#c2e9fb', '#d4fc79', '#96e6a1'
  ];

  const leftPaddle = {
    x: 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };
  const rightPaddle = {
    x: baseWidth - paddleWidth - 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };

  const ball = {
    x: baseWidth / 2,
    y: baseHeight / 2,
    dx: 5,
    dy: 3,
    radius: ballRadius,
    color: ballColors[0]
  };

  let scoreLeft = 0;
  let scoreRight = 0;

  const keys = {};

  let scaleX = 1;
  let scaleY = 1;

  // Таймер 2 минуты (120 секунд)
  let roundDuration = 120;
  let roundStartTime = Date.now();

  function changeBallColor() {
    let newColor;
    do {
      newColor = ballColors[Math.floor(Math.random() * ballColors.length)];
    } while (newColor === ball.color);
    ball.color = newColor;
  }

  function resize() {
    const rect = container.getBoundingClientRect();
    canvas.width = baseWidth;
    canvas.height = baseHeight;

    scaleX = rect.width / baseWidth;
    scaleY = rect.height / baseHeight;

    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';

    leftPaddle.y = Math.min(leftPaddle.y, baseHeight - paddleHeight);
    rightPaddle.y = Math.min(rightPaddle.y, baseHeight - paddleHeight);
    ball.x = baseWidth / 2;
    ball.y = baseHeight / 2;
  }

  window.addEventListener('resize', resize);
  resize();

  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  function updatePaddlesKeyboard() {
    if (keys['w']) {
      leftPaddle.y -= paddleSpeed;
    } else if (keys['s']) {
      leftPaddle.y += paddleSpeed;
    }
    if (keys['arrowup']) {
      rightPaddle.y -= paddleSpeed;
    } else if (keys['arrowdown']) {
      rightPaddle.y += paddleSpeed;
    }
    leftPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, leftPaddle.y));
    rightPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, rightPaddle.y));
  }

  const ongoingTouches = {};

  function getTouchRelativeY(touch) {
    const rect = canvas.getBoundingClientRect();
    return (touch.clientY - rect.top) / scaleY;
  }

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      const rect = canvas.getBoundingClientRect();
      const xRel = (touch.clientX - rect.left) / scaleX;
      if (xRel < baseWidth / 2) {
        ongoingTouches[touch.identifier] = 'left';
      } else {
        ongoingTouches[touch.identifier] = 'right';
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      const paddleSide = ongoingTouches[touch.identifier];
      if (!paddleSide) continue;
      const y = getTouchRelativeY(touch) - paddleHeight / 2;
      if (paddleSide === 'left') {
        leftPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, y));
      } else if (paddleSide === 'right') {
        rightPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, y));
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  canvas.addEventListener('touchcancel', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  function checkPaddleCollision() {
    if (
      ball.x - ball.radius <= leftPaddle.x + paddleWidth &&
      ball.x - ball.radius >= leftPaddle.x &&
      ball.y >= leftPaddle.y &&
      ball.y <= leftPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = leftPaddle.x + paddleWidth + ball.radius;
      changeBallColor();
    }

    if (
      ball.x + ball.radius >= rightPaddle.x &&
      ball.x + ball.radius <= rightPaddle.x + paddleWidth &&
      ball.y >= rightPaddle.y &&
      ball.y <= rightPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = rightPaddle.x - ball.radius;
      changeBallColor();
    }
  }

  function updateBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;

    if (ball.y - ball.radius <= 0) {
      ball.dy = -ball.dy;
      ball.y = ball.radius;
      changeBallColor();
    }
    if (ball.y + ball.radius >= baseHeight) {
      ball.dy = -ball.dy;
      ball.y = baseHeight - ball.radius;
      changeBallColor();
    }

    if (ball.x - ball.radius <= 0) {
      scoreRight++;
      resetBall();
    }
    if (ball.x + ball.radius >= baseWidth) {
      scoreLeft++;
      resetBall();
    }
  }

  function resetBall() {
    ball.x = baseWidth / 2;
    ball.y = baseHeight / 2;
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2);
    ball.dy = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
    ball.color = ballColors[0];
  }

  function drawPaddle(paddle) {
    ctx.fillStyle = '#6c63ff';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#4b47a1';
    ctx.beginPath();
    ctx.moveTo(paddle.x, paddle.y);
    ctx.lineTo(paddle.x + paddleWidth, paddle.y);
    ctx.lineTo(paddle.x + paddleWidth, paddle.y + paddleHeight);
    ctx.lineTo(paddle.x, paddle.y + paddleHeight);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function drawBall() {
    ctx.fillStyle = ball.color;
    ctx.strokeStyle = '#4b47a1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }

  function drawScore() {
    scoreLeftDiv.textContent = scoreLeft;
    scoreRightDiv.textContent = scoreRight;
  }

  function updateTimer() {
    const elapsed = (Date.now() - roundStartTime) / 1000;
    const remaining = Math.max(0, roundDuration - elapsed);
    const minutes = Math.floor(remaining / 60);
    const seconds = Math.floor(remaining % 60);
    timerDiv.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    if (remaining <= 0) {
      // Конец раунда — можно добавить логику остановки игры или перезапуска
      // Для примера просто сбросим счёт и таймер
      scoreLeft = 0;
      scoreRight = 0;
      roundStartTime = Date.now();
      resetBall();
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, baseWidth, baseHeight);

    updatePaddlesKeyboard();
    updateBall();
    checkPaddleCollision();

    drawPaddle(leftPaddle);
    drawPaddle(rightPaddle);
    drawBall();
    drawScore();
    updateTimer();

    requestAnimationFrame(gameLoop);
  }

  function updateInstructionsVisibility() {
    if (window.innerWidth <= 600) {
      instructionsDiv.style.display = 'none';
    } else {
      instructionsDiv.style.display = 'block';
    }
  }
  window.addEventListener('resize', () => {
    resize();
    updateInstructionsVisibility();
  });
  updateInstructionsVisibility();

  resetBall();
  roundStartTime = Date.now();
  gameLoop();
})();
</script>

</body>
</html>
