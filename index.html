<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Ping Pong Game</title><style>
  /* Сброс и базовые стили */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: #f0f0f0;
    display: flex;    justify-content: center;
    align-items: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  #game-container {
    position: relative;
    background: #fff;
    border: 3px solid #222;
    border-radius: 12px;
    box-shadow: 0 0 15px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    touch-action: none;
  }
  #scoreboard {

 height: 40px;
    background: #222;
    color: #eee;
    font-weight: 700;
    font-size: 1.2rem;
    display: flex;
    justify-content: center;
    align-items: center;
    letter-spacing: 0.1em;
    user-select: none;
  }
  canvas {
    display: block;
    background: #fafafa;
    cursor: default;
  }
  #mode-select {
    position: absolute;
    top: 50%;
    left: 50%;    transform: translate(-50%, -50%);
    background: #222;
    color: #eee;
    border-radius: 10px;
    padding: 20px 30px;
    text-align: center;
    z-index: 10;
  user-select: none;
  }
  #mode-select h2 {
    margin: 0 0 15px 0;
    font-weight: 700;
    font-size: 1.5rem;
  }
  #mode-select button {
    background: #444;
    border: none;
    color: #eee;
    font-weight: 600;
    font-size: 1rem;
    padding: 10px 20px;
    margin: 5px 10px;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  #mode-select button:hover {
    background: #666;
  }
  #restart-btn {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: #222;
    color: #eee;
    border: none;
    padding: 8px 14px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    display: none;
  }
  #restart-btn:hover {
    background: #444;
  }
</style>
</head>
<body>

<div id="game-container" style="width: 90vw; max-width: 600px; height: 80vh; max-height: 800px;">
  <div id="scoreboard">0 : 0</div>
  <canvas id="game-canvas"></canvas>
  <button id="restart-btn">Играть снова</button>
  <div id="mode-select">
    <h2>Выберите режим игры</h2>
    <button id="btn-single">Игрок против бота</button>
    <button id="btn-dual">Два игрока</button>
  </div>
</div>

<script>
(() => {
  const container = document.getElementById('game-container');
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const modeSelect = document.getElementById('mode-select');
 const btnSingle = document.getElementById('btn-single');
  const btnDual = document.getElementById('btn-dual');
  const restartBtn = document.getElementById('restart-btn');

  // Настройки игры
  const GAME_DURATION = 120000; // 2 минуты в мс
  const FPS = 60;
  const BALL_RADIUS = 12;
  const PADDLE_THICKNESS = 12;
  const PADDLE_LENGTH_RATIO = 0.2; // длина ракетки относительно поля (20%)
  const COLORS = {
    background: '#fafafa',
    border: '#222',
    paddle: '#222',
    ball: '#222',
    ballHitPaddle: '#0077cc',
    ballHitBorder: '#cc5500',
    scoreboardText: '#eee',
    scoreboardBg: '#222',
  };

  // Определяем устройство и ориентацию
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  let verticalOrientation = isMobile; // вертикальное поле для мобилок

  // Размеры и ориентация поля
  let width, height;
  let paddleLength, paddleThickness;
  let paddle1, paddle2;
  let ball;
  let score1 = 0, score2 = 0;
  let gameMode = null; // 'single' или 'dual'
  let gameRunning = false;
  let gameStartTime = 0;
  let animationFrameId = null;

  // Управление
  let keysPressed = {};
  let touchData = {
    active: false,
    id: null,
    startY: 0,
    startX: 0,
    paddle: null,
  };

  // Цвет мяча для анимации смены цвета при столкновениях
  let ballColor = COLORS.ball;
  let ballColorTimeout = null;

  // Функция для плавного изменения цвета мяча при столкновении
  function flashBallColor(color) {
    ballColor = color;
    if (ballColorTimeout) clearTimeout(ballColorTimeout);
    ballColorTimeout = setTimeout(() => {
      ballColor = COLORS.ball;
    }, 150);
  }

  // Класс ракетки
  class Paddle {
    constructor(x, y, length, thickness, vertical) {
      this.x = x;
      this.y = y;
      this.length = length;
      this.thickness = thickness;
      this.vertical = vertical; // true если вертикальная ракетка (мобильная)
      this.speed = 8;
      this.movePos = 0; // позиция для плавного движения
    }
    draw(ctx) {
      ctx.fillStyle = COLORS.paddle;
      if (this.vertical) {
        ctx.fillRect(this.x, this.y + this.movePos, this.thickness, this.length);
      } else {
        ctx.fillRect(this.x + this.movePos, this.y, this.length, this.thickness);
      }
    }
    // Ограничение движения по полю
    clamp(maxWidth, maxHeight) {
      if (this.vertical) {
        if (this.movePos < 0) this.movePos = 0;
        if (this.movePos + this.length > maxHeight) this.movePos = maxHeight - this.length;
      } else {
        if (this.movePos < 0) this.movePos = 0;
        if (this.movePos + this.length > maxWidth) this.movePos = maxWidth - this.length;
      }
    }
  }

  // Класс мяча
  class Ball {
    constructor(x, y, radius) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.speedX = 0;
      this.speedY = 0;
      this.maxSpeed = 10;
    }
    draw(ctx) {
      ctx.lineWidth = 3;
      ctx.strokeStyle = ballColor;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke()
    }
    reset(centerX, centerY) {
      this.x = centerX;
      this.y = centerY;
      // Случайное направление мяча
      const angle = (Math.random() * Math.PI / 3) - Math.PI / 6; // -30°..+30°
      const direction = Math.random() < 0.5 ? 1 : -1;
      if (verticalOrientation) {
        this.speedX = Math.sin(angle) * this.maxSpeed * direction;
        this.speedY = Math.cos(angle) * this.maxSpeed * (Math.random() < 0.5 ? 1 : -1);
      } else {
        this.speedX = Math.cos(angle) * this.maxSpeed * direction;
        this.speedY = Math.sin(angle) * this.maxSpeed * (Math.random() < 0.5 ? 1 : -1);
      }
    }
    update() {
      this.x += this.speedX;
      this.y += this.speedY;
    }
  }

  // Инициализация размеров и объектов
  function initSizes() {
    const rect = container.getBoundingClientRect();
    width = rect.width;
    height = rect.height - scoreboard.offsetHeight;

    canvas.width = width;
    canvas.height = height;

    paddleThickness = PADDLE_THICKNESS;
    if (verticalOrientation) {
      paddleLength = height * PADDLE_LENGTH_RATIO;
    } else {
      paddleLength = width * PADDLE_LENGTH_RATIO;
    }

    if (verticalOrientation) {
      // Ракетки сверху и снизу, вертикальное поле
      paddle1 = new Paddle(width / 2 - paddleThickness / 2, 0, paddleLength, paddleThickness, true);
      paddle2 = new Paddle(width / 2 - paddleThickness / 2, height - paddleLength, paddleLength, paddleThickness, true);
    } else {
      // Ракетки слева и справа, горизонтальное поле
      paddle1 = new Paddle(0, height / 2 - paddleThickness / 2, paddleLength, paddleThickness, false);
      paddle2 = new Paddle(width - paddleLength, height / 2 - paddleThickness / 2, paddleLength, paddleThickness, false);
    }

    ball = new Ball(width / 2, height / 2, BALL_RADIUS);
    ball.reset(width / 2, height / 2);
  }

  // Отрисовка поля
  function drawField() {
    ctx.clearRect(0, 0, width, height);

    // Рисуем границы поля
    ctx.lineWidth = 4;
    ctx.strokeStyle = COLORS.border;
    ctx.beginPath();
    ctx.rect(0, 0, width, height);
    ctx.stroke()

    // Рисуем пунктирную линию посередине
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 2;
    ctx.setLineDash([10, 15]);
    ctx.beginPath();
    if (verticalOrientation) {
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
    } else {
      ctx.moveTo(width / 2, 0);
      ctx.lineTo(width / 2, height);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Обновление счета на экране
  function updateScoreboard() {
    scoreboard.textContent = `${score1} : ${score2}`;
  }

  // Проверка столкновений мяча с ракетками и стенами
  function checkCollisions() {
    // Столкновение с ракетками
    if (verticalOrientation) {
      // Верхняя ракетка (paddle1)
      if (
        ball.y - ball.radius <= paddle1.length &&
        ball.x + ball.radius >= paddle1.x &&
        ball.x - ball.radius <= paddle1.x + paddle1.thickness &&
        ball.speedY < 0
      ) {
        ball.speedY = -ball.speedY;
        // Смещение мяча чтобы не застрял
        ball.y = paddle1.length + ball.radius;
        flashBallColor(COLORS.ballHitPaddle);
        // Немного меняем скорость по X в зависимости от места удара
        const hitPos = (ball.x - paddle1.x) / paddle1.thickness - 0.5;
        ball.speedX += hitPos * 3;
      }
      // Нижняя ракетка (paddle2)
      if (
        ball.y + ball.radius >= height - paddle2.length &&
        ball.x + ball.radius >= paddle2.x &&
        ball.x - ball.radius <= paddle2.x + paddle2.thickness &&
        ball.speedY > 0
      ) {
        ball.speedY = -ball.speedY;
        ball.y = height - paddle2.length - ball.radius;
        flashBallColor(COLORS.ballHitPaddle);
        const hitPos = (ball.x - paddle2.x) / paddle2.thickness - 0.5;
        ball.speedX += hitPos * 3;
      }
      // Столкновение с боковыми стенами
      if (ball.x - ball.radius <= 0) {
        ball.speedX = -ball.speedX;
        ball.x = ball.radius;
        flashBallColor(COLORS.ballHitBorder);
      }
      if (ball.x + ball.radius >= width) {
        ball.speedX = -ball.speedX;
        ball.x = width - ball.radius;
        flashBallColor(COLORS.ballHitBorder);
      }
    } else {
      // Горизонтальное поле
      // Левая ракетка (paddle1)
      if (
        ball.x - ball.radius <= paddle1.length &&
        ball.y + ball.radius >= paddle1.y &&
        ball.y - ball.radius <= paddle1.y + paddle1.thickness &&
        ball.speedX < 0
      ) {
        ball.speedX = -ball.speedX;
        ball.x = paddle1.length + ball.radius;
        flashBallColor(COLORS.ballHitPaddle);
        const hitPos = (ball.y - paddle1.y) / paddle1.thickness - 0.5;
        ball.speedY += hitPos * 3;
      }
      // Правая ракетка (paddle2)
      if (
        ball.x + ball.radius >= width - paddle2.length &&
        ball.y + ball.radius >= paddle2.y &&
        ball.y - ball.radius <= paddle2.y + paddle2.thickness &&
        ball.speedX > 0
      ) {
        ball.speedX = -ball.speedX;
        ball.x = width - paddle2.length - ball.radius;
        flashBallColor(COLORS.ballHitPaddle);
        const hitPos = (ball.y - paddle2.y) / paddle2.thickness - 0.5;
        ball.speedY += hitPos * 3;
      }
      // Столкновение с верхней и нижней стенами
      if (ball.y - ball.radius <= 0) {
        ball.speedY = -ball.speedY;
        ball.y = ball.radius;
        flashBallColor(COLORS.ballHitBorder);
      }
      if (ball.y + ball.radius >= height) {
        ball.speedY = -ball.speedY;
        ball.y = height - ball.radius;
        flashBallColor(COLORS.ballHitBorder);
      }
    }
  }

  // Проверка забитого гола
  function checkScore() {
    if (verticalOrientation) {
      if (ball.y - ball.radius <= 0) {
        // Гол нижнему игроку (paddle2)
        score2++;
        updateScoreboard();
        resetRound();
      } else if (ball.y + ball.radius >= height) {
        // Гол верхнему игроку (paddle1)
        score1++;
        updateScoreboard();
        resetRound();
      }
    } else {
      if (ball.x - ball.radius <= 0) {
        // Гол правому игроку (paddle2)
        score2++;
        updateScoreboard();
        resetRound();
      } else if (ball.x + ball.radius >= width) {
        // Гол левому игроку (paddle1)
        score1++;
        updateScoreboard();
        resetRound();
      }
    }
  }

  // Сброс мяча и ракеток после гола
  function resetRound() {
    ball.reset(width / 2, height / 2);
    if (verticalOrientation) {
      paddle1.movePos = (height - paddleLength) / 2;
      paddle2.movePos = (height - paddleLength) / 2;
    } else {
      paddle1.movePos = (width - paddleLength) / 2;
      paddle2.movePos = (width - paddleLength) / 2;
    }
  }

  // Управление ракетками игрока
  function handlePlayerInput() {
    if (verticalOrientation) {
      // Вертикальное поле: ракетки двигаются по оси Y (movePos)
      // Игрок 1 (верхняя ракетка) - управление касанием или клавишами W/S
      if (gameMode === 'dual' || gameMode === 'single') {
        if (keysPressed['w'] || keysPressed['W'] || keysPressed['ArrowUp']) {
          paddle1.movePos -= paddle1.speed;
        }
        if (keysPressed['s'] || keysPressed['S'] || keysPressed['ArrowDown']) {
          paddle1.movePos += paddle1.speed;
        }
        paddle1.clamp(width, height);
      }
      // Игрок 2 (нижняя ракетка)
      if (gameMode === 'dual') {
        if (keysPressed['ArrowUp']) {
          paddle2.movePos -= paddle2.speed;
        }
        if (keysPressed['ArrowDown']) {
          paddle2.movePos += paddle2.speed;
        }
        paddle2.clamp(width, height);
      }
    } else {
      // Горизонтальное поле: ракетки двигаются по оси X (movePos)
      // Игрок 1 (левая ракетка) - W/S или стрелки вверх/вниз
      if (gameMode === 'dual' || gameMode === 'single') {
        if (keysPressed['w'] || keysPressed['W']) {
          paddle1.movePos -= paddle1.speed;
        }
        if (keysPressed['s'] || keysPressed['S']) {
          paddle1.movePos += paddle1.speed;
        }
        paddle1.clamp(width, height);
      }
      // Игрок 2 (правая ракетка)
      if (gameMode === 'dual') {
        if (keysPressed['ArrowUp']) {
          paddle2.movePos -= paddle2.speed;
        }
        if (keysPressed['ArrowDown']) {
          paddle2.movePos += paddle2.speed;
        }
        paddle2.clamp(width, height);
      }
    }
  }

  // Управление ботом (игрок 2 в режиме single)
  function handleBot() {
    if (gameMode !== 'single') return;
    const targetPos = verticalOrientation ? ball.x : ball.y;
    const paddle = paddle2;
    const centerPaddle = paddle.movePos + paddle.length / 2;
    const diff = targetPos - centerPaddle;
    const botSpeed = paddle.speed * 0.7;

    if (Math.abs(diff) > 5) {
      if (diff > 0) {
        paddle.movePos += botSpeed;
      } else {
        paddle.movePos -= botSpeed;
      }
      paddle.clamp(width, height);
    }
  }

  // Основной цикл игры
  function gameLoop(timestamp) {
    if (!gameRunning) return;

    // Обновляем позиции
    ball.update();
    checkCollisions();
    checkScore();

    handlePlayerInput();
    handleBot();

    // Отрисовка
    drawField();
    paddle1.draw(ctx);
    paddle2.draw(ctx);
    ball.draw(ctx);

    // Проверка времени
    const elapsed = timestamp - gameStartTime;
    if (elapsed >= GAME_DURATION) {
      endGame();
      return;
    }

    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Запуск игры
  function startGame(mode) {
    gameMode = mode;
    score1 = 0;
    score2 = 0;
    updateScoreboard();
    resetRound();
    modeSelect.style.display = 'none';
    restartBtn.style.display = 'none';
    gameRunning = true;
    gameStartTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  // Окончание игры
  function endGame() {
    gameRunning = false;
    cancelAnimationFrame(animationFrameId);
    restartBtn.style.display = 'block';
    let winnerText = '';
    if (score1 > score2) {
      winnerText = verticalOrientation
        ? 'Победил верхний игрок!'
        : 'Победил левый игрок!';
    } else if (score2 > score1) {
      winnerText = verticalOrientation
        ? 'Победил нижний игрок!'
        : 'Победил правый игрок!';
    } else {
      winnerText = 'Ничья!';
    }
    alert(`Игра окончена!\nСчет: ${score1} : ${score2}\n${winnerText}`);
    modeSelect.style.display = 'block';
  }

  // Обработчики клавиатуры
  window.addEventListener('keydown', e => {
    keysPressed[e.key] = true;
  });
  window.addEventListener('keyup', e => {
    keysPressed[e.key] = false;
  });

  // Обработка касаний для мобильных
  canvas.addEventListener('touchstart', e => {
    if (!gameRunning) return;
    for (const touch of e.changedTouches) {
      // Определяем, какая ракетка ближе к точке касания
      let paddleTouched = null;
      if (verticalOrientation) {
        // Вертикальное поле: ракетки сверху и снизу
        if (touch.clientY < window.innerHeight / 2) {
          paddleTouched = paddle1;
        } else {
          paddleTouched = paddle2;
        }
      } else {
        // Горизонтальное поле: ракетки слева и справа
        if (touch.clientX < window.innerWidth / 2) {
          paddleTouched = paddle1;
        } else {
          paddleTouched = paddle2;
        }
      }
      if (!touchData.active) {
        touchData.active = true;
        touchData.id = touch.identifier;
        touchData.startX = touch.clientX;
        touchData.startY = touch.clientY;
        touchData.paddle = paddleTouched;
      }
    }
  }, { passive: true });

  canvas.addEventListener('touchmove', e => {
    if (!gameRunning) return;
    for (const touch of e.changedTouches) {
      if (touch.identifier === touchData.id && touchData.paddle) {
        if (verticalOrientation) {
          // Двигаем ракетку по X (потому что ракетки вертикальные)
          const deltaX = touch.clientX - touchData.startX;
          touchData.paddle.movePos += deltaX;
          touchData.paddle.clamp(width, height);
          touchData.startX = touch.clientX;
        } else {
          // Двигаем ракетку по Y (ракетки горизонтальные)
          const deltaY = touch.clientY - touchData.startY;
          touchData.paddle.movePos += deltaY;
          touchData.paddle.clamp(width, height);
          touchData.startY = touch.clientY;
        }
      }
    }
  }, { passive: true });

  canvas.addEventListener('touchend', e => {
    for (const touch of e.changedTouches) {
      if (touch.identifier === touchData.id) {
        touchData.active = false;
        touchData.id = null;
        touchData.paddle = null;
      }
    }
  }, { passive: true });

  // Обработка кнопок выбора режима
  btnSingle.addEventListener('click', () => {
    startGame('single');
  });
  btnDual.addEventListener('click', () => {
    startGame('dual');
  });

  // Кнопка рестарта
  restartBtn.addEventListener('click', () => {
    modeSelect.style.display = 'block';
    restartBtn.style.display = 'none';
  });

  // Обновление размеров при изменении окна
  function onResize() {
    // Перепроверяем ориентацию
    const wasVertical = verticalOrientation;
    verticalOrientation = isMobile;

    // Если ориентация изменилась, сбрасываем игру
    if (wasVertical !== verticalOrientation) {
      if (gameRunning) {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        alert('Ориентация устройства изменилась. Игра перезапущена.');
        modeSelect.style.display = 'block';
        restartBtn.style.display = 'none';
      }
    }
    initSizes();
    updateScoreboard();
  }

  window.addEventListener('resize', onResize);

  // Инициализация при загрузке
  function init() {
    initSizes();
    updateScoreboard();
  }

  init();
})();
</script>

</body>
</html>
