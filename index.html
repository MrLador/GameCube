<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–ò–≥—Ä—ã: –ü–∏–Ω–ø–æ–Ω–≥ –∏ –°–∞–ø—ë—Ä —Å –ø–∞–ª–∏—Ç—Ä–∞–º–∏</title>
  <style>
    :root {
      --bg-color: #000;
      --text-color: #fff;
      --btn-bg: #0a84ff;
      --btn-bg-hover: #0066cc;
      --game-bg: #222;
      --paddle-color: #fff;
      --ball-color: #fff;
      --net-color: #fff;
      --rating-bg: #111;
      --rating-border: #fff;
      --ms-cell-bg: #555;
      --ms-cell-revealed-bg: #bbb;
      --ms-cell-flag-color: #f00;
      --ms-cell-text-color: black;
    }
    body {
      margin: 0;
      background: var(--bg-color);
      color: var(--text-color);
      font-family: Arial, sans-serif;
      user-select: none;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #menu {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--game-bg);
    }
    #menu h1 {
      font-size: 48px;
      margin-bottom: 40px;
    }
    #menu button {
      font-size: 24px;
      padding: 15px 40px;
      margin: 15px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: var(--btn-bg);
      color: var(--text-color);
      transition: background 0.3s;
      user-select: none;
    }
    #menu button:hover {
      background: var(--btn-bg-hover);
    }
    #settings {
      margin-top: 30px;
      text-align: center;
      color: var(--text-color);
    }
    #settings label {
      margin-right: 10px;
      font-size: 18px;
    }
    #settings select {
      font-size: 18px;
      padding: 5px 10px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
    }

    /* –û–±—â–∏–µ —Å—Ç–∏–ª–∏ –¥–ª—è –∏–≥—Ä */
    .game-wrapper {
      display: none;
      flex-grow: 1;
      background: var(--game-bg);
      position: relative;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* –ü–∏–Ω–ø–æ–Ω–≥ */
    #pong-container {
      display: flex;
      flex-grow: 1;
      flex-direction: row;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--game-bg);
    }
    canvas {
      background: var(--game-bg);
      border: 2px solid var(--rating-border);
      display: block;
      touch-action: none;
    }
    #score {
      font-size: 24px;
      margin: 10px 0;
      letter-spacing: 10px;
      user-select: none;
      color: var(--text-color);
    }
    #pause-btn, #mode-btn, #pong-back-btn {
      position: absolute;
      background: #444;
      border: none;
      color: var(--text-color);
      font-size: 16px;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
      z-index: 10;
      transition: background 0.3s;
    }
    #pause-btn:hover, #mode-btn:hover, #pong-back-btn:hover {
      background: #666;
    }
    #pause-btn {
      top: 10px;
      left: 10px;
    }
    #mode-btn {
      top: 10px;
      left: 100px;
    }
    #pong-back-btn {
      top: 10px;
      right: 10px;
    }
    #nickname-overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
    }
    #nickname-overlay input {
      font-size: 20px;
      padding: 10px;
      border-radius: 6px;
      border: none;
      width: 250px;
      margin-bottom: 15px;
      text-align: center;
      color: var(--text-color);
      background: #222;
    }
    #nickname-overlay button {
      font-size: 18px;
      padding: 10px 20px;
      border-radius: 6px;
      border: none;
      background: var(--btn-bg);
      color: var(--text-color);
      cursor: pointer;
      user-select: none;
    }
    #nickname-overlay button:hover {
      background: var(--btn-bg-hover);
    }
    #rating {
      width: 300px;
      background: var(--rating-bg);
      border-left: 2px solid var(--rating-border);
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      color: var(--text-color);
    }
    #rating h2 {
      margin-top: 0;
      text-align: center;
      font-weight: normal;
      border-bottom: 1px solid #555;
      padding-bottom: 10px;
    }
    #rating table {
      width: 100%;
      border-collapse: collapse;
      color: var(--text-color);
    }
    #rating th, #rating td {
      padding: 8px 6px;
      border-bottom: 1px solid #444;
      text-align: center;
    }
    #rating th {
      background: #333;
    }
    #rating tbody tr:hover {
      background: #222;
    }
    #rating::-webkit-scrollbar {
      width: 8px;
    }
    #rating::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }

    /* –¶–≤–µ—Ç–∞ –ø–∏–Ω–ø–æ–Ω–≥–∞ –∏–∑ –ø–∞–ª–∏—Ç—Ä—ã */
    .paddle {
      background-color: var(--paddle-color);
    }
    .ball {
      background-color: var(--ball-color);
    }
    .net {
      background-color: var(--net-color);
    }

    /* –°–∞–ø—ë—Ä */
    #minesweeper-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      flex-grow: 1;
      overflow-y: auto;
      background: var(--game-bg);
      width: 100%;
      box-sizing: border-box;
      color: var(--text-color);
    }
    #ms-header {
      width: 100%;
      max-width: 400px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    #ms-header button {
      background: #444;
      border: none;
      color: var(--text-color);
      font-size: 16px;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
      transition: background 0.3s;
    }
    #ms-header button:hover {
      background: #666;
    }
    #ms-status {
      font-size: 18px;
      user-select: none;
    }
    #ms-board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      background: #333;
      border: 2px solid var(--rating-border);
      user-select: none;
    }
    .ms-cell {
      width: 40px;
      height: 40px;
      background: var(--ms-cell-bg);
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-color);
      user-select: none;
      position: relative;
      transition: background 0.3s, color 0.3s;
    }
    .ms-cell.revealed {
      background: var(--ms-cell-revealed-bg);
      color: var(--ms-cell-text-color);
      cursor: default;
    }
    .ms-cell.flagged::after {
      content: "üö©";
      position: absolute;
      font-size: 20px;
      top: 2px;
      right: 2px;
      color: var(--ms-cell-flag-color);
    }
    .ms-cell.mine {
      background: #f00;
      color: black;
    }
  </style>
</head>
<body>
  <!-- –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ –∏–≥—Ä—ã -->
  <div id="menu">
    <h1>–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É</h1>
    <button id="btn-pong">–ü–∏–Ω–ø–æ–Ω–≥</button>
    <button id="btn-minesweeper">–°–∞–ø—ë—Ä</button>

    <div id="settings">
      <label for="palette-select">–¶–≤–µ—Ç–æ–≤–∞—è –ø–∞–ª–∏—Ç—Ä–∞:</label>
      <select id="palette-select" title="–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç–æ–≤—É—é –ø–∞–ª–∏—Ç—Ä—É">
        <option value="default">–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è</option>
        <option value="sunset">–ó–∞–∫–∞—Ç</option>
        <option value="ocean">–û–∫–µ–∞–Ω</option>
        <option value="forest">–õ–µ—Å</option>
        <option value="neon">–ù–µ–æ–Ω</option>
      </select>
    </div>
  </div>

  <!-- –ü–∏–Ω–ø–æ–Ω–≥ -->
  <div id="pong-container" class="game-wrapper">
    <div id="game-container">
      <button id="pause-btn" title="–ü–∞—É–∑–∞">–ü–∞—É–∑–∞</button>
      <button id="mode-btn" title="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ä–µ–∂–∏–º">–†–µ–∂–∏–º: –ü–ö</button>
      <button id="pong-back-btn" title="–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –º–µ–Ω—é">–ú–µ–Ω—é</button>
      <div id="score">0 : 0</div>
      <canvas id="pong" width="800" height="500"></canvas>

      <div id="nickname-overlay">
        <input type="text" id="nickname-input" placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫" maxlength="15" />
        <button id="start-btn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
      </div>
    </div>

    <div id="rating">
      <h2>–†–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–æ–≤</h2>
      <table>
        <thead>
          <tr><th>–ú–µ—Å—Ç–æ</th><th>–ù–∏–∫</th><th>–ü–æ–±–µ–¥—ã</th></tr>
        </thead>
        <tbody id="rating-body">
          <!-- –†–µ–π—Ç–∏–Ω–≥ -->
        </tbody>
      </table>
    </div>
  </div>

  <!-- –°–∞–ø—ë—Ä -->
  <div id="minesweeper-container" class="game-wrapper">
    <div id="ms-header">
      <div id="ms-status">–ú–∏–Ω: 10</div>
      <button id="ms-reset-btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
      <button id="ms-back-btn">–ú–µ–Ω—é</button>
    </div>
    <div id="ms-board"></div>
  </div>

  <script>
    // --- –ü–ê–õ–ò–¢–†–´ ---
    const palettes = {
      default: {
        '--bg-color': '#000000',
        '--text-color': '#ffffff',
        '--btn-bg': '#0a84ff',
        '--btn-bg-hover': '#0066cc',
        '--game-bg': '#222222',
        '--paddle-color': '#ffffff',
        '--ball-color': '#ffffff',
        '--net-color': '#ffffff',
        '--rating-bg': '#111111',
        '--rating-border': '#ffffff',
        '--ms-cell-bg': '#555555',
        '--ms-cell-revealed-bg': '#bbbbbb',
        '--ms-cell-flag-color': '#f00',
        '--ms-cell-text-color': 'black'
      },
      sunset: {
        '--bg-color': '#2c1a1a',
        '--text-color': '#ffd6ba',
        '--btn-bg': '#ff6f61',
        '--btn-bg-hover': '#e65b50',
        '--game-bg': '#3e2f2f',
        '--paddle-color': '#ffb997',
        '--ball-color': '#ff6f61',
        '--net-color': '#ffb997',
        '--rating-bg': '#4a3a3a',
        '--rating-border': '#ffb997',
        '--ms-cell-bg': '#7a4e4e',
        '--ms-cell-revealed-bg': '#ffd6ba',
        '--ms-cell-flag-color': '#ff6f61',
        '--ms-cell-text-color': '#4a2c2c'
      },
      ocean: {
        '--bg-color': '#001f3f',
        '--text-color': '#a7c7e7',
        '--btn-bg': '#0074d9',
        '--btn-bg-hover': '#005fa3',
        '--game-bg': '#003366',
        '--paddle-color': '#7fdbff',
        '--ball-color': '#39cccc',
        '--net-color': '#7fdbff',
        '--rating-bg': '#00264d',
        '--rating-border': '#7fdbff',
        '--ms-cell-bg': '#005580',
        '--ms-cell-revealed-bg': '#a7c7e7',
        '--ms-cell-flag-color': '#39cccc',
        '--ms-cell-text-color': '#00334d'
      },
      forest: {
        '--bg-color': '#0b3d0b',
        '--text-color': '#c6f6c6',
        '--btn-bg': '#2ecc40',
        '--btn-bg-hover': '#27ae34',
        '--game-bg': '#145214',
        '--paddle-color': '#a3d9a5',
        '--ball-color': '#2ecc40',
        '--net-color': '#a3d9a5',
        '--rating-bg': '#1e5a1e',
        '--rating-border': '#a3d9a5',
        '--ms-cell-bg': '#2a6f2a',
        '--ms-cell-revealed-bg': '#c6f6c6',
        '--ms-cell-flag-color': '#27ae34',
        '--ms-cell-text-color': '#144214'
      },
      neon: {
        '--bg-color': '#0f0f0f',
        '--text-color': '#39ff14',
        '--btn-bg': '#39ff14',
        '--btn-bg-hover': '#2ecc40',
        '--game-bg': '#121212',
        '--paddle-color': '#39ff14',
        '--ball-color': '#ff00ff',
        '--net-color': '#39ff14',
        '--rating-bg': '#1a1a1a',
        '--rating-border': '#39ff14',
        '--ms-cell-bg': '#222222',
        '--ms-cell-revealed-bg': '#39ff14',
        '--ms-cell-flag-color': '#ff00ff',
        '--ms-cell-text-color': '#121212'
      }
    };

    // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø–∞–ª–∏—Ç—Ä—É CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    function applyPalette(name) {
      const palette = palettes[name] || palettes.default;
      for (const varName in palette) {
        document.documentElement.style.setProperty(varName, palette[varName]);
      }
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø–∞–ª–∏—Ç—Ä—É –∏–∑ localStorage
    const paletteSelect = document.getElementById('palette-select');
    function savePalette(name) {
      localStorage.setItem('selectedPalette', name);
    }
    function loadPalette() {
      const saved = localStorage.getItem('selectedPalette');
      if (saved && palettes[saved]) {
        return saved;
      }
      return 'default';
    }

    paletteSelect.value = loadPalette();
    applyPalette(paletteSelect.value);

    paletteSelect.addEventListener('change', () => {
      const val = paletteSelect.value;
      applyPalette(val);
      savePalette(val);
    });

    // --- –ú–ï–ù–Æ ---
    const menu = document.getElementById('menu');
    const btnPong = document.getElementById('btn-pong');
    const btnMinesweeper = document.getElementById('btn-minesweeper');

    const pongContainer = document.getElementById('pong-container');
    const minesweeperContainer = document.getElementById('minesweeper-container');

    btnPong.onclick = () => {
      menu.style.display = 'none';
      minesweeperContainer.style.display = 'none';
      pongContainer.style.display = 'flex';
    };
    btnMinesweeper.onclick = () => {
      menu.style.display = 'none';
      pongContainer.style.display = 'none';
      minesweeperContainer.style.display = 'flex';
      minesweeperGame.init();
    };

    // --- –ü–ò–ù–ü–û–ù–ì ---
    (function(){
      const canvas = document.getElementById('pong');
      const ctx = canvas.getContext('2d');

      const paddleWidth = 10;
      const paddleHeight = 100;
      const ballRadius = 10;

      let playerY, botY, ballX, ballY;
      let ballSpeedX, ballSpeedY;

      const paddleSpeed = 7;

      let playerScore = 0;
      let botScore = 0;

      let upPressed = false;
      let downPressed = false;

      let isPaused = false;
      let gameStarted = false;

      let hitCount = 0;

      let playerNick = '';

      let rating = [];

      let gameMode = 'pc';

      let touchStartY = null;
      let playerTouchY = null;

      const scoreEl = document.getElementById('score');
      const pauseBtn = document.getElementById('pause-btn');
      const modeBtn = document.getElementById('mode-btn');
      const nicknameOverlay = document.getElementById('nickname-overlay');
      const nicknameInput = document.getElementById('nickname-input');
      const startBtn = document.getElementById('start-btn');
      const ratingBody = document.getElementById('rating-body');
      const pongBackBtn = document.getElementById('pong-back-btn');

      function initPositions() {
        playerY = (canvas.height - paddleHeight) / 2;
        botY = (canvas.height - paddleHeight) / 2;
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballSpeedX = 5 * (Math.random() > 0.5 ? 1 : -1);
        ballSpeedY = 3 * (Math.random() > 0.5 ? 1 : -1);
        hitCount = 0;
      }

      function setupKeyboardControls() {
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
      }
      function removeKeyboardControls() {
        document.removeEventListener('keydown', onKeyDown);
        document.removeEventListener('keyup', onKeyUp);
      }
      function onKeyDown(e) {
        if (!gameStarted || isPaused) return;
        if (e.key === 'ArrowUp') upPressed = true;
        if (e.key === 'ArrowDown') downPressed = true;
      }
      function onKeyUp(e) {
        if (!gameStarted || isPaused) return;
        if (e.key === 'ArrowUp') upPressed = false;
        if (e.key === 'ArrowDown') downPressed = false;
      }

      function setupTouchControls() {
        canvas.addEventListener('touchstart', onTouchStart, {passive: false});
        canvas.addEventListener('touchmove', onTouchMove, {passive: false});
        canvas.addEventListener('touchend', onTouchEnd, {passive: false});
      }
      function removeTouchControls() {
        canvas.removeEventListener('touchstart', onTouchStart);
        canvas.removeEventListener('touchmove', onTouchMove);
        canvas.removeEventListener('touchend', onTouchEnd);
      }
      function onTouchStart(e) {
        if (!gameStarted || isPaused) return;
        const touch = e.touches[0];
        if (touch.clientX < canvas.getBoundingClientRect().left + canvas.width / 2) {
          touchStartY = touch.clientY;
          playerTouchY = playerY + paddleHeight / 2;
          e.preventDefault();
        }
      }
      function onTouchMove(e) {
        if (!gameStarted || isPaused) return;
        if (touchStartY === null) return;
        const touch = e.touches[0];
        if (touch.clientX < canvas.getBoundingClientRect().left + canvas.width / 2) {
          const deltaY = touch.clientY - touchStartY;
          playerY = playerTouchY + deltaY;
          if (playerY < 0) playerY = 0;
          if (playerY > canvas.height - paddleHeight) playerY = canvas.height - paddleHeight;
          e.preventDefault();
        }
      }
      function onTouchEnd(e) {
        touchStartY = null;
        playerTouchY = null;
      }

      function toggleGameMode() {
        if (gameMode === 'pc') {
          gameMode = 'mobile';
          modeBtn.textContent = '–†–µ–∂–∏–º: –ú–æ–±–∏–ª—å–Ω—ã–π';
          canvas.width = 400;
          canvas.height = 600;
          resetGame();
          removeKeyboardControls();
          setupTouchControls();
        } else {
          gameMode = 'pc';
          modeBtn.textContent = '–†–µ–∂–∏–º: –ü–ö';
          canvas.width = 800;
          canvas.height = 500;
          resetGame();
          removeTouchControls();
          setupKeyboardControls();
        }
      }

      pauseBtn.addEventListener('click', () => {
        if (!gameStarted) return;
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '–ü–∞—É–∑–∞';
      });

      modeBtn.addEventListener('click', () => {
        toggleGameMode();
      });

      startBtn.addEventListener('click', () => {
        const nick = nicknameInput.value.trim();
        if (nick.length === 0) {
          alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–∏–∫.');
          return;
        }
        playerNick = nick;
        nicknameOverlay.style.display = 'none';
        gameStarted = true;
        resetGame();
        if (gameMode === 'pc') {
          setupKeyboardControls();
        } else {
          setupTouchControls();
        }
        gameLoop();
      });

      pongBackBtn.addEventListener('click', () => {
        gameStarted = false;
        isPaused = false;
        removeKeyboardControls();
        removeTouchControls();
        pongContainer.style.display = 'none';
        menu.style.display = 'flex';
      });

      function drawRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
      }

      function drawCircle(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
      }

      function drawNet() {
        const netWidth = 4;
        const netHeight = 20;
        const netColor = getComputedStyle(document.documentElement).getPropertyValue('--net-color').trim() || '#fff';
        for (let i = 0; i < canvas.height; i += netHeight * 2) {
          drawRect((canvas.width - netWidth) / 2, i, netWidth, netHeight, netColor);
        }
      }

      function resetBall(direction = 1) {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballSpeedX = 5 * direction;
        ballSpeedY = 3 * (Math.random() > 0.5 ? 1 : -1);
        hitCount = 0;
      }

      function resetGame() {
        playerScore = 0;
        botScore = 0;
        updateScore();
        playerY = (canvas.height - paddleHeight) / 2;
        botY = (canvas.height - paddleHeight) / 2;
        resetBall(1);
        isPaused = false;
        pauseBtn.textContent = '–ü–∞—É–∑–∞';
      }

      function updateScore() {
        scoreEl.textContent = `${playerScore} : ${botScore}`;
      }

      function increaseBallSpeed() {
        ballSpeedX *= 1.1;
        ballSpeedY *= 1.1;
      }

      function update() {
        if (isPaused) return;

        if (gameMode === 'pc') {
          if (upPressed && playerY > 0) playerY -= paddleSpeed;
          if (downPressed && playerY < canvas.height - paddleHeight) playerY += paddleSpeed;
        }

        ballX += ballSpeedX;
        ballY += ballSpeedY;

        if (ballY + ballRadius > canvas.height || ballY - ballRadius < 0) {
          ballSpeedY = -ballSpeedY;
        }

        if (
          ballX - ballRadius < paddleWidth &&
          ballY > playerY &&
          ballY < playerY + paddleHeight
        ) {
          ballSpeedX = -ballSpeedX;
          let deltaY = ballY - (playerY + paddleHeight / 2);
          ballSpeedY = deltaY * 0.3;

          hitCount++;
          if (hitCount % 2 === 0) {
            increaseBallSpeed();
          }
        }

        if (
          ballX + ballRadius > canvas.width - paddleWidth &&
          ballY > botY &&
          ballY < botY + paddleHeight
        ) {
          ballSpeedX = -ballSpeedX;
          let deltaY = ballY - (botY + paddleHeight / 2);
          ballSpeedY = deltaY * 0.3;

          hitCount++;
          if (hitCount % 2 === 0) {
            increaseBallSpeed();
          }
        }

        if (ballX - ballRadius < 0) {
          botScore++;
          updateScore();
          if (checkGameOver()) return;
          resetBall(1);
        } else if (ballX + ballRadius > canvas.width) {
          playerScore++;
          updateScore();
          if (checkGameOver()) return;
          resetBall(-1);
        }

        const botCenter = botY + paddleHeight / 2;
        if (botCenter < ballY - 35) {
          botY += paddleSpeed * 0.6;
        } else if (botCenter > ballY + 35) {
          botY -= paddleSpeed * 0.6;
        }

        if (botY < 0) botY = 0;
        if (botY > canvas.height - paddleHeight) botY = canvas.height - paddleHeight;
      }

      function draw() {
        drawRect(0, 0, canvas.width, canvas.height, getComputedStyle(document.documentElement).getPropertyValue('--game-bg').trim() || '#222');
        drawNet();
        drawRect(0, playerY, paddleWidth, paddleHeight, getComputedStyle(document.documentElement).getPropertyValue('--paddle-color').trim() || '#fff');
        drawRect(canvas.width - paddleWidth, botY, paddleWidth, paddleHeight, getComputedStyle(document.documentElement).getPropertyValue('--paddle-color').trim() || '#fff');
        drawCircle(ballX, ballY, ballRadius, getComputedStyle(document.documentElement).getPropertyValue('--ball-color').trim() || '#fff');
      }

      function checkGameOver() {
        const maxScore = 10;
        if (playerScore >= maxScore || botScore >= maxScore) {
          isPaused = true;
          pauseBtn.textContent = '–ü–∞—É–∑–∞';
          setTimeout(() => {
            alert(playerScore > botScore ? `–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º, ${playerNick}! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!` : '–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏. –°–ª–µ–¥—É—é—â–∏–π –∏–≥—Ä–æ–∫, –≤–≤–µ–¥–∏—Ç–µ –Ω–∏–∫.');
            if (playerScore > botScore) {
              updateRating(playerNick);
            }
            nicknameInput.value = '';
            nicknameOverlay.style.display = 'flex';
            gameStarted = false;
            removeKeyboardControls();
            removeTouchControls();
          }, 100);
          return true;
        }
        return false;
      }

      function updateRating(nick) {
        const playerEntry = rating.find(r => r.nick === nick);
        if (playerEntry) {
          playerEntry.wins++;
        } else {
          rating.push({ nick: nick, wins: 1 });
        }
        rating.sort((a, b) => b.wins - a.wins);
        renderRating();
      }

      function renderRating() {
        ratingBody.innerHTML = '';
        rating.forEach((player, index) => {
          const tr = document.createElement('tr');
          const placeTd = document.createElement('td');
          placeTd.textContent = index + 1;
          const nickTd = document.createElement('td');
          nickTd.textContent = player.nick;
          const winsTd = document.createElement('td');
          winsTd.textContent = player.wins;
          tr.appendChild(placeTd);
          tr.appendChild(nickTd);
          tr.appendChild(winsTd);
          ratingBody.appendChild(tr);
        });
      }

      function gameLoop() {
        if (!gameStarted) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      canvas.width = 800;
      canvas.height = 500;
      initPositions();
    })();

    // --- –°–ê–ü–Å–† ---
    const minesweeperGame = (function(){
      const boardSize = 9;
      const mineCount = 10;

      let board = [];
      let revealedCount = 0;
      let flagsCount = 0;
      let gameOver = false;
      let firstClick = true;

      const msBoard = document.getElementById('ms-board');
      const msStatus = document.getElementById('ms-status');
      const msResetBtn = document.getElementById('ms-reset-btn');
      const msBackBtn = document.getElementById('ms-back-btn');

      function init() {
        gameOver = false;
        revealedCount = 0;
        flagsCount = 0;
        firstClick = true;
        msStatus.textContent = `–ú–∏–Ω: ${mineCount}`;
        board = [];
        msBoard.innerHTML = '';
        msBoard.style.gridTemplateColumns = `repeat(${boardSize}, 40px)`;
        msBoard.style.gridTemplateRows = `repeat(${boardSize}, 40px)`;

        for(let i=0; i<boardSize; i++) {
          board[i] = [];
          for(let j=0; j<boardSize; j++) {
            board[i][j] = {
              mine: false,
              revealed: false,
              flagged: false,
              adjacent: 0,
              element: null
            };
            const cell = document.createElement('div');
            cell.classList.add('ms-cell');
            cell.dataset.row = i;
            cell.dataset.col = j;
            msBoard.appendChild(cell);
            board[i][j].element = cell;
          }
        }

        msBoard.addEventListener('click', onCellClick);
        msBoard.addEventListener('contextmenu', onCellRightClick);

        msResetBtn.onclick = () => {
          init();
        };
        msBackBtn.onclick = () => {
          msBoard.removeEventListener('click', onCellClick);
          msBoard.removeEventListener('contextmenu', onCellRightClick);
          minesweeperContainer.style.display = 'none';
          menu.style.display = 'flex';
        };
      }

      // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –º–∏–Ω —Å —É—á—ë—Ç–æ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∑–æ–Ω—ã –≤–æ–∫—Ä—É–≥ –ø–µ—Ä–≤–æ–π –æ—Ç–∫—Ä—ã—Ç–æ–π –∫–ª–µ—Ç–∫–∏
      function placeMinesSafe(firstRow, firstCol) {
        let placed = 0;
        const safeCells = new Set();

        // –î–æ–±–∞–≤–ª—è–µ–º –≤ –±–µ–∑–æ–ø–∞—Å–Ω—É—é –∑–æ–Ω—É –ø–µ—Ä–≤—É—é –∫–ª–µ—Ç–∫—É –∏ —Å–æ—Å–µ–¥–µ–π
        for(let dr=-1; dr<=1; dr++) {
          for(let dc=-1; dc<=1; dc++) {
            const nr = firstRow + dr;
            const nc = firstCol + dc;
            if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
              safeCells.add(nr + ',' + nc);
            }
          }
        }

        while(placed < mineCount) {
          const r = Math.floor(Math.random() * boardSize);
          const c = Math.floor(Math.random() * boardSize);
          if (!board[r][c].mine && !safeCells.has(r + ',' + c)) {
            board[r][c].mine = true;
            placed++;
          }
        }
      }

      function calculateAdjacents() {
        for(let r=0; r<boardSize; r++) {
          for(let c=0; c<boardSize; c++) {
            if (board[r][c].mine) {
              board[r][c].adjacent = -1;
              continue;
            }
            let count = 0;
            for(let dr=-1; dr<=1; dr++) {
              for(let dc=-1; dc<=1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                  if (board[nr][nc].mine) count++;
                }
              }
            }
            board[r][c].adjacent = count;
          }
        }
      }

      function onCellClick(e) {
        if (gameOver) return;
        const cell = e.target;
        if (!cell.classList.contains('ms-cell')) return;
        const r = +cell.dataset.row;
        const c = +cell.dataset.col;
        const cellData = board[r][c];
        if (cellData.flagged || cellData.revealed) return;

        if (firstClick) {
          // –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –∫–ª–∏–∫–µ —Ä–∞–∑–º–µ—â–∞–µ–º –º–∏–Ω—ã —Å –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∑–æ–Ω–æ–π
          placeMinesSafe(r, c);
          calculateAdjacents();
          firstClick = false;
        }

        revealCell(r, c);
        checkWin();
      }

      function onCellRightClick(e) {
        e.preventDefault();
        if (gameOver) return;
        const cell = e.target;
        if (!cell.classList.contains('ms-cell')) return;
        const r = +cell.dataset.row;
        const c = +cell.dataset.col;
        const cellData = board[r][c];
        if (cellData.revealed) return;
        if (cellData.flagged) {
          cellData.flagged = false;
          cell.classList.remove('flagged');
          flagsCount--;
        } else {
          if (flagsCount < mineCount) {
            cellData.flagged = true;
            cell.classList.add('flagged');
            flagsCount++;
          }
        }
        msStatus.textContent = `–ú–∏–Ω: ${mineCount - flagsCount}`;
      }

      function revealCell(r, c) {
        const cellData = board[r][c];
        if (cellData.revealed || cellData.flagged) return;
        cellData.revealed = true;
        revealedCount++;
        cellData.element.classList.add('revealed');
        if (cellData.mine) {
          cellData.element.classList.add('mine');
          gameOver = true;
          revealAllMines();
          msStatus.textContent = '–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏!';
          alert('–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏! –ù–∞–∂–º–∏—Ç–µ "–ù–æ–≤–∞—è –∏–≥—Ä–∞" –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏.');
          return;
        }
        if (cellData.adjacent > 0) {
          cellData.element.textContent = cellData.adjacent;
          cellData.element.style.color = getNumberColor(cellData.adjacent);
        } else {
          for(let dr=-1; dr<=1; dr++) {
            for(let dc=-1; dc<=1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr;
              const nc = c + dc;
              if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
                revealCell(nr, nc);
              }
            }
          }
        }
      }

      function revealAllMines() {
        for(let r=0; r<boardSize; r++) {
          for(let c=0; c<boardSize; c++) {
            if (board[r][c].mine) {
              board[r][c].element.classList.add('revealed', 'mine');
            }
          }
        }
      }

      function checkWin() {
        if (gameOver) return;
        if (revealedCount === boardSize*boardSize - mineCount) {
          gameOver = true;
          msStatus.textContent = '–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!';
          alert('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!');
        }
      }

      function getNumberColor(num) {
        switch(num) {
          case 1: return 'blue';
          case 2: return 'green';
          case 3: return 'red';
          case 4: return 'darkblue';
          case 5: return 'brown';
          case 6: return 'cyan';
          case 7: return 'black';
          case 8: return 'gray';
          default: return 'black';
        }
      }

      return {
        init
      };
    })();
  </script>
</body>
</html>
