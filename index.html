<!DOCTYPE html>
<html>
<head>
    <title>Dust Racer Pro</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #2c3e50; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            background: #27ae60;
            border: 2px solid #34495e;
        }
        #hud {
            position: fixed; 
            top: 10px; 
            left: 10px;
            color: white; 
            font-family: Arial; 
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="hud">Laps: <span id="laps">0</span>/2</div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SCALE = 0.7;
canvas.width = 1200 * SCALE;
canvas.height = 900 * SCALE;

const TRACK = [
    {x: 600, y: 800, w: 400},    // Стартовая прямая
    {x: 600, y: 500, w: 400, r: 30}, 
    {x: 900, y: 200, w: 400, r: 100}, 
    {x: 600, y: -100, w: 400},    
    {x: 300, y: 200, w: 400, r: -100}, 
    {x: 600, y: 500, w: 400, r: -30}  
];

class Car {
    constructor(color) {
        this.reset();
        this.color = color;
        this.maxSpeed = 8;
    }

    reset() {
        this.x = 600 * SCALE;
        this.y = 800 * SCALE;
        this.speed = 0;
        this.angle = 90; // Начальный угол смотрит вверх
        this.laps = 0;
        this.checkpoint = 0;
        this.velocity = { x: 0, y: 0 };
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate((this.angle - 90) * Math.PI / 180); // Корректировка направления
        
        // Кузов
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.roundRect(-20*SCALE, -10*SCALE, 40*SCALE, 20*SCALE, 5*SCALE);
        ctx.fill();
        
        // Стекло
        ctx.fillStyle = '#ecf0f1';
        ctx.beginPath();
        ctx.roundRect(-15*SCALE, -8*SCALE, 30*SCALE, 10*SCALE, 3*SCALE);
        ctx.fill();
        
        // Колёса
        ctx.fillStyle = '#2c3e50';
        [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([x, y]) => {
            ctx.beginPath();
            ctx.arc(x * 25*SCALE, y * 15*SCALE, 5*SCALE, 0, Math.PI*2);
            ctx.fill();
        });
        
        ctx.restore();
    }

    update() {
        // Обновление позиции с учетом вектора движения
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        
        // Постепенное замедление
        this.velocity.x *= 0.96;
        this.velocity.y *= 0.96;
    }
}

const player = new Car('#e74c3c');
const bots = Array.from({length: 5}, (_, i) => 
    new Car(['#3498db', '#9b59b6', '#2ecc71', '#f1c40f', '#95a5a6'][i]));

function init() {
    bots.forEach((bot, i) => {
        bot.reset();
        bot.x += (i - 2) * 60 * SCALE;
        bot.maxSpeed = 6 + Math.random() * 2;
    });
}

function drawTrack() {
    ctx.fillStyle = '#7f8c8d';
    TRACK.forEach(segment => {
        ctx.beginPath();
        ctx.roundRect(
            (segment.x - segment.w/2) * SCALE, 
            segment.y * SCALE, 
            segment.w * SCALE, 
            200 * SCALE, 
            20 * SCALE
        );
        ctx.fill();
    });
}

function aiMove(bot) {
    const target = TRACK[bot.checkpoint % TRACK.length];
    const dx = target.x * SCALE - bot.x;
    const dy = target.y * SCALE - bot.y;
    
    // Плавный поворот
    const targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
    bot.angle += ((targetAngle + 90) - bot.angle) * 0.1;
    
    if(Math.hypot(dx, dy) < 80 * SCALE) {
        bot.checkpoint = (bot.checkpoint + 1) % TRACK.length;
    }
    
    // Управление скоростью
    const acceleration = 0.1;
    bot.velocity.x += Math.cos((bot.angle - 90) * Math.PI / 180) * acceleration;
    bot.velocity.y += Math.sin((bot.angle - 90) * Math.PI / 180) * acceleration;
    
    // Ограничение скорости
    const speed = Math.hypot(bot.velocity.x, bot.velocity.y);
    if(speed > bot.maxSpeed) {
        bot.velocity.x = (bot.velocity.x / speed) * bot.maxSpeed;
        bot.velocity.y = (bot.velocity.y / speed) * bot.maxSpeed;
    }
}

function checkCollision(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y) < 40 * SCALE;
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTrack();
    
    // Обновление ботов
    bots.forEach(bot => {
        aiMove(bot);
        bot.update();
        bot.draw();
    });
    
    // Обновление игрока
    player.update();
    player.draw();
    
    // Проверка кругов
    if(player.checkpoint >= TRACK.length) {
        player.laps++;
        document.getElementById('laps').textContent = player.laps;
        player.checkpoint = 0;
        if(player.laps >= 2) {
            alert('Победа!');
            init();
            player.reset();
            return;
        }
    }
    
    // Проверка чекпоинтов
    TRACK.forEach((seg, i) => {
        if(Math.hypot(
            player.x - seg.x * SCALE, 
            player.y - seg.y * SCALE
        ) < 80 * SCALE) {
            if(i === player.checkpoint) player.checkpoint++;
        }
    });
    
    // Коллизии
    bots.forEach(bot => {
        if(checkCollision(player, bot)) {
            const dx = player.x - bot.x;
            const dy = player.y - bot.y;
            const force = 0.8;
            
            player.velocity.x += dx * force;
            player.velocity.y += dy * force;
            bot.velocity.x -= dx * force;
            bot.velocity.y -= dy * force;
        }
    });
    
    requestAnimationFrame(gameLoop);
}

// Новое управление с разделением поворота и ускорения
document.addEventListener('keydown', e => {
    const turnSpeed = 4;
    const acceleration = 0.15;
    
    if(e.key === 'ArrowLeft') {
        player.angle -= turnSpeed;
    }
    if(e.key === 'ArrowRight') {
        player.angle += turnSpeed;
    }
    if(e.key === 'ArrowUp') {
        player.velocity.x += Math.cos((player.angle - 90) * Math.PI / 180) * acceleration;
        player.velocity.y += Math.sin((player.angle - 90) * Math.PI / 180) * acceleration;
    }
    if(e.key === 'ArrowDown') {
        player.velocity.x -= Math.cos((player.angle - 90) * Math.PI / 180) * acceleration * 0.5;
        player.velocity.y -= Math.sin((player.angle - 90) * Math.PI / 180) * acceleration * 0.5;
    }
    
    // Ограничение скорости
    const speed = Math.hypot(player.velocity.x, player.velocity.y);
    if(speed > player.maxSpeed) {
        player.velocity.x = (player.velocity.x / speed) * player.maxSpeed;
        player.velocity.y = (player.velocity.y / speed) * player.maxSpeed;
    }
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth * SCALE;
    canvas.height = window.innerHeight * SCALE;
});

init();
gameLoop();
</script>
</body>
</html>
