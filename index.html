<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Vector Pong — повернутая мобильная версия</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(135deg, #a8edea, #fed6e3);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    background: #f0f4f8;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    border-radius: 20px;
    touch-action: none;
    width: 800px;
    height: 450px;
  }
  canvas {
    display: block;
    background: #e0e7ff;
    border-radius: 20px;
    box-shadow: inset 0 0 30px #c0d8ff;
    width: 800px;
    height: 450px;
    transform-origin: center center;
    transition: transform 0.3s ease;
  }
  #scoreContainer {
    position: absolute;
    width: 100%;
    top: 10px;
    display: flex;
    justify-content: center;
    font-size: 2rem;
    font-weight: 700;
    color: #4a4a4a;
    user-select: none;
    pointer-events: none;
  }
  #scoreLeft, #scoreRight {
    user-select: none;
  }
  #scoreLeft::after {
    content: " : ";
    margin: 0 10px;
    color: #4a4a4a;
  }
  #scoreRight::after {
    content: "";
  }
  #timer {
    position: absolute;
    top: 50px;
    width: 100%;
    text-align: center;
    font-size: 1.5rem;
    font-weight: 600;
    color: #4a4a4a;
    user-select: none;
    pointer-events: none;
  }
  #instructions {
    font-size: 1rem;
    color: #666;
    margin-top: 10px;
    user-select: none;
  }

  /* Мобильная версия — поворот canvas и контейнера */
  @media (max-width: 600px) {
    #gameContainer {
      width: 90vw;
      height: calc(90vw * 1.7777); /* 800/450 = 1.7777 */
      max-height: 90vh;
      transform: rotate(90deg);
      transform-origin: center center;
    }
    canvas {
      width: 100%;
      height: 100%;
      transform: none !important; /* отменяем поворот canvas, т.к. поворачиваем контейнер */
    }
    #scoreContainer {
      top: 10px;
      flex-direction: row;
      justify-content: space-between;
      padding: 0 20px;
      width: 100%;
    }
    #scoreLeft, #scoreRight {
      flex: 1;
      text-align: center;
      margin: 0;
    }
    #scoreLeft::after {
      content: "";
    }
    #instructions {
      display: none;
    }
    #timer {
      top: 50px;
    }
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="800" height="450"></canvas>
  <div id="scoreContainer">
    <div id="scoreLeft">0</div>
    <div id="scoreRight">0</div>
  </div>
  <div id="timer">2:00</div>
  <div id="instructions">Управление: W/S и стрелки вверх/вниз</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreLeftDiv = document.getElementById('scoreLeft');
  const scoreRightDiv = document.getElementById('scoreRight');
  const timerDiv = document.getElementById('timer');
  const instructionsDiv = document.getElementById('instructions');

  const baseWidth = 800;
  const baseHeight = 450;

  const paddleWidth = 15;
  const paddleHeight = 100;
  const paddleSpeed = 6;
  const ballRadius = 12;

  const ballColors = [
    '#a8edea', '#fed6e3', '#fcb69f', '#a1c4fd', '#c2e9fb', '#d4fc79', '#96e6a1'
  ];

  const leftPaddle = {
    x: 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };
  const rightPaddle = {
    x: baseWidth - paddleWidth - 10,
    y: baseHeight / 2 - paddleHeight / 2,
    dy: 0
  };

  const ball = {
    x: baseWidth / 2,
    y: baseHeight / 2,
    dx: 5,
    dy: 3,
    radius: ballRadius,
    color: ballColors[0]
  };

  let scoreLeft = 0;
  let scoreRight = 0;

  const keys = {};

  // Таймер 2 минуты (120 секунд)
  let roundDuration = 120;
  let roundStartTime = Date.now();

  function changeBallColor() {
    let newColor;
    do {
      newColor = ballColors[Math.floor(Math.random() * ballColors.length)];
    } while (newColor === ball.color);
    ball.color = newColor;
  }

  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  function updatePaddlesKeyboard() {
    if (keys['w']) {
      leftPaddle.y -= paddleSpeed;
    } else if (keys['s']) {
      leftPaddle.y += paddleSpeed;
    }
    if (keys['arrowup']) {
      rightPaddle.y -= paddleSpeed;
    } else if (keys['arrowdown']) {
      rightPaddle.y += paddleSpeed;
    }
    leftPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, leftPaddle.y));
    rightPaddle.y = Math.max(0, Math.min(baseHeight - paddleHeight, rightPaddle.y));
  }

  const ongoingTouches = {};

  function getTouchRelativeY(touch) {
    const rect = canvas.getBoundingClientRect();
    return (touch.clientY - rect.top);
  }

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      const rect = canvas.getBoundingClientRect();
      const xRel = (touch.clientX - rect.left);
      if (xRel < rect.width / 2) {
        ongoingTouches[touch.identifier] = 'left';
      } else {
        ongoingTouches[touch.identifier] = 'right';
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      const paddleSide = ongoingTouches[touch.identifier];
      if (!paddleSide) continue;
      const rect = canvas.getBoundingClientRect();
      let y = touch.clientY - rect.top - paddleHeight / 2;
      y = Math.max(0, Math.min(rect.height - paddleHeight, y));
      // Преобразуем координаты касания в координаты канваса (учитывая масштаб)
      const scaleY = baseHeight / rect.height;
      const yGame = y * scaleY;
      if (paddleSide === 'left') {
        leftPaddle.y = yGame;
      } else if (paddleSide === 'right') {
        rightPaddle.y = yGame;
      }
    }
  }, { passive: false });

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  canvas.addEventListener('touchcancel', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
      delete ongoingTouches[touch.identifier];
    }
  }, { passive: false });

  function checkPaddleCollision() {
    if (
      ball.x - ball.radius <= leftPaddle.x + paddleWidth &&
      ball.x - ball.radius >= leftPaddle.x &&
      ball.y >= leftPaddle.y &&
      ball.y <= leftPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = leftPaddle.x + paddleWidth + ball.radius;
      changeBallColor();
    }

    if (
      ball.x + ball.radius >= rightPaddle.x &&
      ball.x + ball.radius <= rightPaddle.x + paddleWidth &&
      ball.y >= rightPaddle.y &&
      ball.y <= rightPaddle.y + paddleHeight
    ) {
      ball.dx = -ball.dx;
      ball.x = rightPaddle.x - ball.radius;
      changeBallColor();
    }
  }

  function updateBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;

    if (ball.y - ball.radius <= 0) {
      ball.dy = -ball.dy;
      ball.y = ball.radius;
      changeBallColor();
    }
    if (ball.y + ball.radius >= baseHeight) {
      ball.dy = -ball.dy;
      ball.y = baseHeight - ball.radius;
      changeBallColor();
    }

    if (ball.x - ball.radius <= 0) {
      scoreRight++;
      resetBall();
    }
    if (ball.x + ball.radius >= baseWidth) {
      scoreLeft++;
      resetBall();
    }
  }

  function resetBall() {
    ball.x = baseWidth / 2;
    ball.y = baseHeight / 2;
    ball.dx = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2);
    ball.dy = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
    ball.color = ballColors[0];
  }

  function drawPaddle(paddle) {
    const grad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x + paddleWidth, paddle.y + paddleHeight);
    grad.addColorStop(0, '#6c63ff');
    grad.addColorStop(1, '#4b47a1');

    ctx.fillStyle = grad;
    ctx.lineJoin = 'round';
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#4b47a1';
    const radius = 10;
    ctx.beginPath();
    ctx.moveTo(paddle.x + radius, paddle.y);
    ctx.lineTo(paddle.x + paddleWidth - radius, paddle.y);
    ctx.quadraticCurveTo(paddle.x + paddleWidth, paddle.y, paddle.x + paddleWidth, paddle.y + radius);
    ctx.lineTo(paddle.x + paddleWidth, paddle.y + paddleHeight - radius);
    ctx.quadraticCurveTo(paddle.x + paddleWidth, paddle.y + paddleHeight, paddle.x + paddleWidth - radius, paddle.y + paddleHeight);
    ctx.lineTo(paddle.x + radius, paddle.y + paddleHeight);
    ctx.quadraticCurveTo(paddle.x, paddle.y + paddleHeight, paddle.x, paddle.y + paddleHeight - radius);
    ctx.lineTo(paddle.x, paddle.y + radius);
    ctx.quadraticCurveTo(paddle.x, paddle.y, paddle.x + radius, paddle.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function drawBall() {
    ctx.fillStyle = ball.color;
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 3;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#4b47a1';
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  function drawScore() {
    scoreLeftDiv.textContent = scoreLeft;
    scoreRightDiv.textContent = scoreRight;
  }

  function updateTimer() {
    const elapsed = (Date.now() - roundStartTime) / 1000;
    const remaining = Math.max(0, roundDuration - elapsed);
    const minutes = Math.floor(remaining / 60);
    const seconds = Math.floor(remaining % 60);
    timerDiv.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

    if (remaining <= 0) {
      scoreLeft = 0;
      scoreRight = 0;
      roundStartTime = Date.now();
      resetBall();
    }
  }

  function gameLoop() {
    ctx.clearRect(0, 0, baseWidth, baseHeight);

    updatePaddlesKeyboard();
    updateBall();
    checkPaddleCollision();

    drawPaddle(leftPaddle);
    drawPaddle(rightPaddle);
    drawBall();
    drawScore();
    updateTimer();

    requestAnimationFrame(gameLoop);
  }

  function updateInstructionsVisibility() {
    if (window.innerWidth <= 600) {
      instructionsDiv.style.display = 'none';
    } else {
      instructionsDiv.style.display = 'block';
    }
  }
  window.addEventListener('resize', updateInstructionsVisibility);
  updateInstructionsVisibility();

  resetBall();
  roundStartTime = Date.now();
  gameLoop();
})();
</script>

</body>
</html>
