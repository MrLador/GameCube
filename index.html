<!DOCTYPE html>
<html>
<head>
    <title>Dust Racer Final</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #2ecc71; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            background: #27ae60;
            border: 2px solid #34495e;
        }
        #hud {
            position: fixed; 
            top: 10px; 
            left: 10px;
            color: white; 
            font-family: Arial; 
            font-size: 20px;
            text-shadow: 2px 2px 2px black;
        }
    </style>
</head>
<body>
    <div id="hud">Laps: <span id="laps">0</span>/2</div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SCALE = 0.8;
canvas.width = 1000 * SCALE;
canvas.height = 800 * SCALE;

// Полностью переработанный трек в форме восьмёрки
const TRACK = [
    {x: 500, y: 700, w: 300, type: 'straight'},  // Старт
    {x: 700, y: 500, w: 300, r: 90},            // Правый поворот
    {x: 500, y: 300, w: 300, type: 'straight'}, // Верхняя прямая
    {x: 300, y: 500, w: 300, r: -90},           // Левый поворот
    {x: 500, y: 700, w: 300, type: 'straight'}  // Финиш
];

class Car {
    constructor(color) {
        this.reset();
        this.color = color;
        this.maxSpeed = 8;
        this.steering = 0;
    }

    reset() {
        this.x = 500 * SCALE;
        this.y = 700 * SCALE;
        this.speed = 0;
        this.angle = 0; // 0 = вправо, 90 = вверх
        this.laps = 0;
        this.checkpoint = 0;
        this.velocity = { x: 0, y: 0 };
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate((this.angle + 90) * Math.PI / 180); // Исправленное вращение
        
        // Кузов с тенью
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 5;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.roundRect(-20*SCALE, -10*SCALE, 40*SCALE, 20*SCALE, 5*SCALE);
        ctx.fill();
        
        // Стекло
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.roundRect(-15*SCALE, -8*SCALE, 30*SCALE, 10*SCALE, 3*SCALE);
        ctx.fill();
        
        // Колёса с анимацией
        ctx.fillStyle = '#2c3e50';
        [[-1, -1], [1, -1], [-1, 1], [1, 1]].forEach(([x, y]) => {
            ctx.beginPath();
            ctx.arc(x * 25*SCALE, y * 15*SCALE, 5*SCALE, 0, Math.PI*2);
            ctx.fill();
        });
        
        ctx.restore();
    }

    update() {
        // Плавное управление
        this.angle += this.steering * (this.speed * 0.1);
        this.velocity.x = Math.cos((this.angle) * Math.PI / 180) * this.speed;
        this.velocity.y = Math.sin((this.angle) * Math.PI / 180) * this.speed;
        
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        
        // Естественное замедление
        this.speed *= 0.97;
        this.steering *= 0.9;
    }
}

const player = new Car('#e74c3c');
const bots = Array.from({length: 3}, (_, i) => 
    new Car(['#3498db', '#9b59b6', '#2ecc71'][i]));

function init() {
    bots.forEach((bot, i) => {
        bot.reset();
        bot.x += (i - 1) * 80 * SCALE;
        bot.y += 50 * SCALE;
        bot.maxSpeed = 6 + Math.random() * 2;
    });
}

function drawTrackSegment(segment) {
    ctx.fillStyle = '#7f8c8d';
    ctx.strokeStyle = '#34495e';
    ctx.lineWidth = 5*SCALE;
    
    if(segment.r) {
        // Рисуем поворот
        ctx.beginPath();
        ctx.arc(
            segment.x * SCALE, 
            segment.y * SCALE, 
            segment.w * SCALE, 
            Math.PI*0.5, 
            Math.PI*1.5
        );
        ctx.fill();
        ctx.stroke();
    } else {
        // Прямая
        ctx.beginPath();
        ctx.roundRect(
            (segment.x - segment.w/2) * SCALE,
            segment.y * SCALE - 100*SCALE,
            segment.w * SCALE,
            200*SCALE,
            20*SCALE
        );
        ctx.fill();
        ctx.stroke();
    }
}

function aiMove(bot) {
    const target = TRACK[bot.checkpoint % TRACK.length];
    const dx = target.x * SCALE - bot.x;
    const dy = target.y * SCALE - bot.y;
    
    const targetAngle = (Math.atan2(dy, dx) * 180 / Math.PI) - 90;
    const angleDiff = ((targetAngle - bot.angle + 180) % 360) - 180;
    
    bot.steering = Math.max(-3, Math.min(3, angleDiff * 0.1));
    bot.speed = Math.min(bot.maxSpeed, bot.speed + 0.05);
    
    if(Math.hypot(dx, dy) < 100 * SCALE) {
        bot.checkpoint = (bot.checkpoint + 1) % TRACK.length;
    }
}

function checkCollision(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y) < 40 * SCALE;
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Рисуем трек
    TRACK.forEach(drawTrackSegment);
    
    // Обновляем ботов
    bots.forEach(bot => {
        aiMove(bot);
        bot.update();
        bot.draw();
    });
    
    // Обновляем игрока
    player.update();
    player.draw();
    
    // Проверка кругов
    if(player.checkpoint >= TRACK.length) {
        player.laps++;
        document.getElementById('laps').textContent = player.laps;
        player.checkpoint = 0;
        if(player.laps >= 2) {
            alert('Победа!');
            init();
            player.reset();
            return;
        }
    }
    
    // Проверка чекпоинтов
    TRACK.forEach((seg, i) => {
        const dist = Math.hypot(
            player.x - seg.x * SCALE, 
            player.y - seg.y * SCALE
        );
        
        if(dist < 120 * SCALE && i === player.checkpoint) {
            player.checkpoint++;
        }
    });
    
    // Коллизии
    bots.forEach(bot => {
        if(checkCollision(player, bot)) {
            const force = 0.5;
            player.x += (player.x - bot.x) * force;
            player.y += (player.y - bot.y) * force;
        }
    });
    
    requestAnimationFrame(gameLoop);
}

// Управление с инерцией
document.addEventListener('keydown', e => {
    switch(e.key) {
        case 'ArrowLeft':
            player.steering -= 2;
            break;
        case 'ArrowRight':
            player.steering += 2;
            break;
        case 'ArrowUp':
            player.speed = Math.min(player.maxSpeed, player.speed + 0.3);
            break;
        case 'ArrowDown':
            player.speed = Math.max(-3, player.speed - 0.5);
            break;
    }
});

init();
gameLoop();
</script>
</body>
</html>
